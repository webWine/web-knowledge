# 垃圾回收
## 一、垃圾回收是什么
    程序运行过程中会产生一些无用的“垃圾”，这些“垃圾”包括程序已经使用后面不再使用的对象、函数等占用的内存空间以及程序压根就不会使用的内存（例如一些多余的变量）等，来及回收就是专门清理这些内存的
## 二、垃圾如何产生的
    程序编写过程中创建的对象、函数等在程序执行结束就不再使用或者是在程序执行过程中就已经确定不会再使用的变量、函数等都可以被称为垃圾，可以通过“可达性”来判断哪些是垃圾，可达性指的是在垃圾回收过程中从程序顶部开始
    访问内部的局部变量，所有访问不到的变量、函数等都被称为垃圾
## 三、为什么要垃圾回收
    浏览器给js提供的运行环境中分配的内存是有限的，如果不进行垃圾回收，随着程序的不断执行，垃圾会越来越多，占用的内存也会越来最大，最终当占用内存超出限制之后，程序就会崩溃，即使没有超出限制也会由于大量占用内存空间
    导致程序性能变差
## 四、垃圾回收的方案
### 4.1、标记清除（主流方法）
#### 4.1.1、策略
    分为标记和清除两个阶段，主要步骤如下：
    第一步：程序运行时给内存中的所有变量都加上标记0，预设他们全部为垃圾
    第二步：从根对象开始遍历，将所有遍历不到的节点标记为1；
    第三步：清理所有标记为0的垃圾变量，销毁并回收他们所占用的内存空间；
    第四步：最后，将所有的变量标记为0，等待下轮垃圾回收进行鉴别回收
#### 4.1.2、优点
    实现简单，只需要打标记，改标记即可
#### 4.1.3、缺点
##### A、内存碎片化
    标记清除法在回收内存后，剩余内存的位置是不变的，这就会导致内存空间中的可用内存空间不连续。
##### B、分配速度慢
    由于垃圾回收后内存空间不连续，此时为新对象进行内存分配时就需要考虑在众多的不连续可用空间中应该使用哪个最为合理。这就需要进行一定的计算了。
    常用的方案有以下几种：假设待分配内存空间大小为N
    A、First-fit，找到大于等于N的区块立马返回
    B、Best-fit，遍历所有空闲区间，找到大于等于N的最小分块；
    C、Worst-fit，遍历整个列表找到最大的分块，然后切成两部分，一部分大小为N，并将该部分返回；
    三种策略中，C策略看起来是最合理的，但是切分之后实际会造成更多的小块，形成了更多的内存碎片，所以不太合理，而A、B两种策略中，考虑到分配效率，
    A显然效率更高，所以三种方案中A是最为合适的。
#### 4.1.4、标记清除缺点的优化策略
    标记清除带来的问题显而易见，即使采用上面的方案A也会造成内存浪费；因此就出现了标记整理算法。
    标记整理算法：标记结束后将未回收的对象向内存的一端移动，最后清理掉边界内存。这样就会将剩余的内存空间合并到一起，分配的时候也会更简单，直接按照顺序即可
### 4.2、引用计数
    引用计数法的策略就是对象每被引用一次，就在对象的引用次数上加一（对象或变量的声明也算一次引用），当变量或对象的值被覆盖时就在引用次数上减一
#### 4.2.1、优点
    回收及时，当变量的引用次数为0后就能回收，回收效率更高
#### 4.2.2 缺点
##### A、回收过程可能需要占用大量的内存
    引用计数法，顾名思义在整个垃圾回收过程中需要开辟一块内存用来存储变量与引用次数的关系，我门并不清楚程序中到底会有多少变量以及程序中大量使用
    变量但不及时手动清理的话这个变量与引用次数关系的变量将会占据极大的内存，这会影响程序的性能
##### B、循环引用问题
    在程序中如果存在变量循环引用问题，比如a引用b，b引用a，那么a、b的引用次数都变成了2（包含一次a、b的变量声明），当程序执行结束，很明显a、b无法被清理
## 五、V8对垃圾回收策略的优化
### 5.1、分代回收策略
    V8针对上面的问题做了一些优化，首先就是提出了分代回收策略，。
    分代回收：指的是将垃圾回收区域分为新老区域，针对具有特性的对象进行特定方法的处理；将新、小、生存周期短的对象放在新生代内存中；将老、大、生
             存周期长的对象分配的老生代空间。
##### A、新生代回收
    新生代垃圾回收占有1～8Mb的内存空间，新生代采用了一种名叫Scavenge的算法，而在Scavenge的算法中主要采用了一种叫Cheney的算法，该算法将新生
    代内存空间一分为二，分为使用区和空闲区；具体步骤如下：
    1、将新加入的对象都写入使用去，当使用快要写满时做一次垃圾清理
    2、垃圾回收执行时，新生代垃圾回收器回对使用区的对象做标记，标记完成后将使用区的无需清理的对象复制到空闲区并排序，如果复制的对象大小超过了空
    闲区的25%，直接将该对象放到老生代区间（这是因为使用区已使用内存占比过大会影响后续的内存分配）
    3、复制完成后，将空闲区改为使用区，使用区改为空闲区，继续进行内存分配与垃圾回收
_为什么要将新生代空间分为两块？_ 
    因为在垃圾回收过程中可能存在内存分配的情况，如果不分区就在一个空间区域内处理就会比较混乱
##### B、老生代回收
    老生代区间内都是一些生命周期长、内存占比大、老的对象。如果考虑上面的方案显然不合理（复制大对象耗费性能），因此对于老生代区间内的内存回收还
    是以标记清除方法为主；但仅仅使用标记清除效率并不是很高，V8就在这里考虑了并行回收方案、写屏障等
### 5.2、并行回收
    开启一个主任务和多个辅助任务，主任务和辅助任务并行执行
### 5.3、增量标记与懒性清理