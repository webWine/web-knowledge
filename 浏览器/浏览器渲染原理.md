# 在浏览器地址栏输入内容后发生了什么？
## 一、输入内容处理
    浏览器根据输入的内容判断当前输入信息是一个url还是一个检索信息，
    如果是检索信息：直接构建一个检索请求的url，调用浏览器默认的搜索引擎进行搜索；
    如果是url：进入域名解析阶段
## 二、域名解析
### 1、域名查询（浏览器缓存）
    地址栏输入url后，浏览器首先会在浏览器中查询当前域名是由有域名映射关系的缓存
### 2、系统磁盘缓存（host文件）
    如果浏览器缓存中查询到域名缓存，浏览器将会去系统的host文件中查询是否有域名映射的缓存，如果有则直接使用，如果没
    有则选择去DNS服务器中优先查询缓存
### 3、路由器缓存
### 4、域名解析服务器缓存
### 5、DNS解析
    如果在前面的缓存中都没有查询到域名对应的ip，那么就将去DNS解析服务器上查询并解析域名，DNS解析的过程就是逐级查询，但一般运行商的服务器会
    将查询过程封装好，DNS域名解析在查询到运营商的服务器时，运营商的服务器会自动执行域名查询过程的方法。域名查询的原理也很简单，根据域名结构
    （以a.baidu.com）可以将域名拆分为顶级域名.com等，一级域名则是baidu.com，二级域名则是在一级域名下注册的a，DNS在解析过程如下：
    第一步：查询根域名服务器，得到顶级域名.com（LTD服务器）对应的的服务器IP
    第二步：选择顶级域名对应的服务器IP中的任意一个，在顶级域名服务器下查询一级域名baidu.com对应的服务器IP
    第三步：选择任意一个一级域名对应的服务器IP去查询二级域名的服务器IP，到此，我们就能得到访问的url对应的具体服务器IP
## 三、HTTP连接
    url被解析完成后,就将进行HTTP连接。
### 1、三次握手
    三次握手的过程其实就是双方交换序列号，在握手过程中我们主要关注标记位（SYN=1||ACK=1）、确认号（接收端告诉发送端上一次数据包发送有效，
    已成功接收，可以解决丢包问题）、序列号
    第一次：客户端——>服务器，客户端生成一个随机序列号client_isn,客户端向服务器发送一个标记位（SYN=1）和序列号，表示客户端将要进行连接，
    客户端进入SYN_SEND阶段
    第二次：服务器——>客户端，服务器接收到客户端传来的标记位和序列号，将返回一个标记位（ACK=1）和服务器的序列号server_isn以及确认号
    client_isn+1,ACK=1表示服务器接收到客户端的请求进行应答，服务器进入SYN_RCVD阶段
    第三次：客户端——>服务器，客户端收到服务器返回的序列号、确认号、标记位等，确认无误后，就向服务器发送一个标记位（ACK=1）和一个确认号
    server_isn+1，此后客户端与服务器进入连接等待状态
#### 1.1、为什么是三次握手而不是两次
    我们观察三次握手的过程，发现最后两次都是在相互确认，如果只有两次，那么就只有客户端确认服务器具有可连接的能力，但服务器并不清楚客户端此时
    是否能够连接，如果此时服务器开始进行报文传输，那假设客户端又刚好不能连接那就会造成无畏的损耗
### 2、https的建立过程
    第一步：主机A向主机B发送加密连接请求，将支持的加密版本、加密算法、生成的随机数等信息带在请求中发送给主机B
    第二步：主机B接受到请求，确认双方加密的SSL/TSL协议版本，如果浏览器不支持，则关闭加密，此外还需确认双方使用的加密算法，并将主机B的CA证
    书以及生成的随机数返回给主机A
    第三步：主机A进行CA证书验证，如果验证证书合法，取出CA证书中的公钥，并使用该公钥加密主机A生成的新的随机数，通知主机B更换加密算法，并将
    前面产生的所有数据再次发送给主机B用于验证，主机A此时在加密阶段就处于握手结束阶段
    第四步：主机B接收到加密后的随机数后，使用自己的私钥解密，此时主机A与主机B此时都得到了三个随机数，接下来就用双方协商好的加密算法生成会话
    密钥，后续都将用该会话密钥进行通信，并将前面生成的所有数据返回给客户端进行校验。此时主机B也将处于加密阶段的握手结束时刻
### 3、浏览器缓存
    经过三次握手与https进行数据加密后，HTTP连接就正式建立，此时就将进行数据的传输，但在数据的传输过程中，HTTP会对传输的数据做一些缓存处理
    ，浏览器缓存分为 强缓存、协商缓存
    强缓存：向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强缓存由以下几种结果：
           A、不存在该缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求——————200
           B、存在缓存结果和缓存标识，但缓存结果失效，则进行协商缓存
           C、存在缓存结果和缓存标识，缓存结果未失效，直接返回该结果
           在HTTP/1.0中，强制缓存使用Expires,该结果是一个时间绝对值，具体到了缓存结束的哪一分哪一秒，但如果服务器和客户端的时区不一致，
           那这个时间就有问题了，或者修改本地时间到缓存有效期之后也会导致缓存失效
           在HTTP/1.1中就提出Cache-Control，他的结果是一个相对值，例如Cache-Control：max-age=6000，6000的单位是毫秒，这是一个相对
           时间，这样无论即使浏览器时区与服务器时区不一致，在一个相对时间内都不会影响缓存失效，它解决了1.0中的问题，当两者同时出现时他的优先级更高
           TIPS：强制缓存中，我们需要注意强制缓存的缓存结果会存在多个地方，包括from memory cache和from disk cache
                内存缓存（from memory cache）：该缓存是指缓存结果存在运行内存中的那部分缓存结果，缓存会随着程序关闭而被清空，这就导致他
                具有一定的时效性因为该缓存结果存放在程序运行内容中，所以读取效率更高。该缓存中存入的是当前页面中已经抓取到的资源,例如页面
                上已经下载的样式、脚本、图片等
                硬盘盘缓存（from disk cache）：硬盘缓存是将文件直接写入硬盘进行缓存，读取文件也都是从硬盘进行I/O操作，然后重新解析该缓存
                内容，速度比内存缓存要慢，一般回将大文件存入硬盘缓存
    协商缓存：强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存表示决定是否需要缓存标识的过程，协商缓存生效请求状态将返回304
            协商缓存有以下几个标识：
            A、Etag，文件的唯一标识，当文件发生变化时，该值会发生改变，由服务器返回，弥补了文件出现变化，但last-modidfied为变化的缺陷
            B、last-modified，文件的最新修改时间，由服务器返回，依然存在时区问题，如果在两次修改过程中服务器设置了不同时区导致了时间一致
            就会产生问题
            C、if-modified-since，浏览器在发现缓存已经过期的情况情况下，在请求过程中将上一次请求返回的last-modified的值作为当前属性的
            属性值发送到服务器
            D、if-none-match，浏览器发现缓存已过期时带上的字段，值为上一次请求返回的Etag
            协商缓存的过程如下：
                缓存过期后，浏览器将会在请求时添加if-none-match，值为上一次请求返回的Etag，服务器在接收到请求后将接收到的值与当前的
                ETag做对比，如果一致则返回304状态，不返回任何实际内容，表示去浏览器中去缓存文件即可，如果有变化，则直接重新发起请求，
                返回200，并将新的Etag记录，if-modified同理

### 4、四次挥手（断开连接）
#### 4.1、断开过程
    第一次：主机A向主机B发送FIN码，值位1（表示主机A请求断开连接）以及一个由主机A生成的序列号a_isn，主机A进入FIN_WAIT1阶段
    第二次：主机B收到主机A发来的确认断开连接请求，立马向主机A发送一个确认收到消息，该消息包括一个标记位ACK=1、服务器序列号b_isn以及确认号
           a_isn+1,主机A进入FIN_WAIT2阶段，主机B进入CLOSE_WAIT阶段
    第三次：主机B等待数据发送完毕，向主机A发送断开请求，包含一个标记位（FIN=1）、服务器序列号b_isn以及确认号a_isn+1,主机B进入LAST_ACK阶段
    第四次：主机A接收到主机B发来的断开请求后，立即对主机B发送回复消息，消息包含标记位（ACK=1）、确认号b_isn+1、序列号a_isn+1，此时主机A
           进入TIME_WAIT阶段，等待两个MSL后断开连接，主机B在接收到消息后断开连接
#### 4.2、为什么要等待2MSL
    MSL：报文最大生存时间
    首先第一个MSL是为了保证主机A最后一次的断开确认请求能够到达主机B，因为如果在主机A发送出最后一次确认断开消息后，因为某些原因（网差等）主
    机B在一段时间内没有接收到最后一次的确认消息时，会再次向主机A发送FIN消息，如果主机A不等待的话，此时就无法接受这条消息；
    至于需要两个MSL的原因是在该阶段数据已经传输完毕，此时是否需要完美关闭光没有那么重要，如果考虑关闭的话那需要等待更多的MSL，这没有必要。
    目的：等待2MSL的真正目的是为了避免前后两个相同使用四元组连接中的前一个干扰后一个，假设在极端情况下，主机A在1MSL的最后一刻向主机B发送了
         确认关闭消息，而主机B在接收到确认断开连接前一直在发送关闭请求，而这个关闭请求最晚会在1MSL内失效，这个1MSL是在B接收消息的前一刻才
         开始计算，那么完整的时间就应该为1MSL+1MSL-x（FIN开始发送时间和B接收ACK消息的时间中间的差值），所以需要2MSL才能保证下一次不会影响上一次
#### 4.3、为什么是四次挥手不是三次
    根据断开过程考虑即可
## 三、浏览器渲染（用的时候再详细了解，内容较散）
    1、解析HTML构成DOM树
    2、解析CSS构成CSSOM树
    3、合并DOM树与Render树
    4、布局Render树
    5、绘制Render树