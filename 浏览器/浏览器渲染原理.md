# 在浏览器地址栏输入内容后发生了什么？
## 一、输入内容处理
    浏览器根据输入的内容判断当前输入信息是一个url还是一个检索信息，
    如果是检索信息：直接构建一个检索请求的url，调用浏览器默认的搜索引擎进行搜索；
    如果是url：进入域名解析阶段
## 二、域名解析
### 1、域名查询（浏览器缓存）
    地址栏输入url后，浏览器首先会在浏览器中查询当前域名是由有域名映射关系的缓存
### 2、系统磁盘缓存（host文件）
    如果浏览器缓存中查询到域名缓存，浏览器将会去系统的host文件中查询是否有域名映射的缓存，如果有则直接使用，如果没
    有则选择去DNS服务器中优先查询缓存
### 3、路由器缓存
### 4、域名解析服务器缓存
### 5、DNS解析
    如果在前面的缓存中都没有查询到域名对应的ip，那么就将去DNS解析服务器上查询并解析域名，DNS解析的过程就是逐级查询，但一般运行商的服务器会
    将查询过程封装好，DNS域名解析在查询到运营商的服务器时，运营商的服务器会自动执行域名查询过程的方法。域名查询的原理也很简单，根据域名结构
    （以a.baidu.com）可以将域名拆分为顶级域名.com等，一级域名则是baidu.com，二级域名则是在一级域名下注册的a，DNS在解析过程如下：
    第一步：查询根域名服务器，得到顶级域名.com（LTD服务器）对应的的服务器IP
    第二步：选择顶级域名对应的服务器IP中的任意一个，在顶级域名服务器下查询一级域名baidu.com对应的服务器IP
    第三步：选择任意一个一级域名对应的服务器IP去查询二级域名的服务器IP，到此，我们就能得到访问的url对应的具体服务器IP
## 三、HTTP连接
    url被解析完成后,就将进行HTTP连接。
### 1、三次握手
    三次握手的过程其实就是双方交换序列号，在握手过程中我们主要关注标记位（SYN=1||ACK=1）、确认号（接收端告诉发送端上一次数据包发送有效，
    已成功接收，可以解决丢包问题）、序列号
    第一次：客户端——>服务器，客户端生成一个随机序列号client_isn,客户端向服务器发送一个标记位（SYN=1）和序列号，表示客户端将要进行连接，
    客户端进入SYN_SEND阶段
    第二次：服务器——>客户端，服务器接收到客户端传来的标记位和序列号，将返回一个标记位（ACK=1）和服务器的序列号server_isn以及确认号
    client_isn+1,ACK=1表示服务器接收到客户端的请求进行应答，服务器进入SYN_RCVD阶段
    第三次：客户端——>服务器，客户端收到服务器返回的序列号、确认号、标记位等，确认无误后，就向服务器发送一个标记位（ACK=1）和一个确认号
    server_isn+1，此后客户端与服务器进入连接等待状态
#### 1.1、为什么是三次握手而不是两次
    我们观察三次握手的过程，发现最后两次都是在相互确认，如果只有两次，那么就只有客户端确认服务器具有可连接的能力，但服务器并不清楚客户端此时
    是否能够连接，如果此时服务器开始进行报文传输，那假设客户端又刚好不能连接那就会造成无畏的损耗
### 2、https的建立过程
    第一步：主机A向主机B发送加密连接请求，将支持的加密版本、加密算法、生成的随机数等信息带在请求中发送给主机B
    第二步：主机B接受到请求，确认双方加密的SSL/TSL协议版本，如果浏览器不支持，则关闭加密，此外还需确认双方使用的加密算法，并将主机B的CA证
    书以及生成的随机数返回给主机A
    第三步：主机A进行CA证书验证，如果验证证书合法，取出CA证书中的公钥，并使用该公钥加密主机A生成的新的随机数，通知主机B更换加密算法，并将
    前面产生的所有数据再次发送给主机B用于验证，主机A此时在加密阶段就处于握手结束阶段
    第四步：主机B接收到加密后的随机数后，使用自己的私钥解密，此时主机A与主机B此时都得到了三个随机数，接下来就用双方协商好的加密算法生成会话
    密钥，后续都将用该会话密钥进行通信，并将前面生成的所有数据返回给客户端进行校验。此时主机B也将处于加密阶段的握手结束时刻
### 3、浏览器缓存
    经过三次握手与https进行数据加密后，HTTP连接就正式建立，此时就将进行数据的传输，但在数据的传输过程中，HTTP会对传输的数据做一些缓存处理
    ，浏览器缓存分为 强缓存、协商缓存
    强缓存：向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强缓存由以下几种结果：
           A、不存在该缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求——————200
           B、存在缓存结果和缓存标识，但缓存结果失效，则进行协商缓存
           C、存在缓存结果和缓存标识，缓存结果未失效，直接返回该结果
           在HTTP/1.0中，强制缓存使用Expires,该结果是一个时间绝对值，具体到了缓存结束的哪一分哪一秒，但如果服务器和客户端的时区不一致，
           那这个时间就有问题了，或者修改本地时间到缓存有效期之后也会导致缓存失效
           在HTTP/1.1中就提出Cache-Control，他的结果是一个相对值，例如Cache-Control：max-age=6000，6000的单位是毫秒，这是一个相对
           时间，这样无论即使浏览器时区与服务器时区不一致，在一个相对时间内都不会影响缓存失效，它解决了1.0中的问题，当两者同时出现时他的优先级更高
           TIPS：强制缓存中，我们需要注意强制缓存的缓存结果会存在多个地方，包括from memory cache和from disk cache
                内存缓存（from memory cache）：该缓存是指缓存结果存在运行内存中的那部分缓存结果，缓存会随着程序关闭而被清空，这就导致他
                具有一定的时效性因为该缓存结果存放在程序运行内容中，所以读取效率更高。该缓存中存入的是当前页面中已经抓取到的资源,例如页面
                上已经下载的样式、脚本、图片等
                硬盘盘缓存（from disk cache）：硬盘缓存是将文件直接写入硬盘进行缓存，读取文件也都是从硬盘进行I/O操作，然后重新解析该缓存
                内容，速度比内存缓存要慢，一般回将大文件存入硬盘缓存
    协商缓存：强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存表示决定是否需要缓存标识的过程，协商缓存生效请求状态将返回304
            协商缓存有以下几个标识：
            A、Etag，文件的唯一标识，当文件发生变化时，该值会发生改变，由服务器返回，弥补了文件出现变化，但last-modidfied为变化的缺陷
            B、last-modified，文件的最新修改时间，由服务器返回，依然存在时区问题，如果在两次修改过程中服务器设置了不同时区导致了时间一致
            就会产生问题
            C、if-modified-since，浏览器在发现缓存已经过期的情况情况下，在请求过程中将上一次请求返回的last-modified的值作为当前属性的
            属性值发送到服务器
            D、if-none-match，浏览器发现缓存已过期时带上的字段，值为上一次请求返回的Etag
            协商缓存的过程如下：
                缓存过期后，浏览器将会在请求时添加if-none-match，值为上一次请求返回的Etag，服务器在接收到请求后将接收到的值与当前的
                ETag做对比，如果一致则返回304状态，不返回任何实际内容，表示去浏览器中去缓存文件即可，如果有变化，则直接重新发起请求，
                返回200，并将新的Etag记录，if-modified同理
                    
### 4、四次挥手（断开连接）
    
## 三、浏览器渲染